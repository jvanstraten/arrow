// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: selection.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_selection_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_selection_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3016000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3016000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_selection_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_selection_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_selection_2eproto;
namespace io {
namespace substrait {
class FieldReference;
struct FieldReferenceDefaultTypeInternal;
extern FieldReferenceDefaultTypeInternal _FieldReference_default_instance_;
class MaskExpression;
struct MaskExpressionDefaultTypeInternal;
extern MaskExpressionDefaultTypeInternal _MaskExpression_default_instance_;
class MaskExpression_ListSelect;
struct MaskExpression_ListSelectDefaultTypeInternal;
extern MaskExpression_ListSelectDefaultTypeInternal _MaskExpression_ListSelect_default_instance_;
class MaskExpression_ListSelect_ListSelectItem;
struct MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal;
extern MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal _MaskExpression_ListSelect_ListSelectItem_default_instance_;
class MaskExpression_ListSelect_ListSelectItem_ListElement;
struct MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal;
extern MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal _MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_;
class MaskExpression_ListSelect_ListSelectItem_ListSlice;
struct MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal;
extern MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal _MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_;
class MaskExpression_MapSelect;
struct MaskExpression_MapSelectDefaultTypeInternal;
extern MaskExpression_MapSelectDefaultTypeInternal _MaskExpression_MapSelect_default_instance_;
class MaskExpression_MapSelect_MapKey;
struct MaskExpression_MapSelect_MapKeyDefaultTypeInternal;
extern MaskExpression_MapSelect_MapKeyDefaultTypeInternal _MaskExpression_MapSelect_MapKey_default_instance_;
class MaskExpression_MapSelect_MapKeyExpression;
struct MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal;
extern MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal _MaskExpression_MapSelect_MapKeyExpression_default_instance_;
class MaskExpression_Select;
struct MaskExpression_SelectDefaultTypeInternal;
extern MaskExpression_SelectDefaultTypeInternal _MaskExpression_Select_default_instance_;
class MaskExpression_StructItem;
struct MaskExpression_StructItemDefaultTypeInternal;
extern MaskExpression_StructItemDefaultTypeInternal _MaskExpression_StructItem_default_instance_;
class MaskExpression_StructSelect;
struct MaskExpression_StructSelectDefaultTypeInternal;
extern MaskExpression_StructSelectDefaultTypeInternal _MaskExpression_StructSelect_default_instance_;
class ReferenceSegment;
struct ReferenceSegmentDefaultTypeInternal;
extern ReferenceSegmentDefaultTypeInternal _ReferenceSegment_default_instance_;
class ReferenceSegment_ListElement;
struct ReferenceSegment_ListElementDefaultTypeInternal;
extern ReferenceSegment_ListElementDefaultTypeInternal _ReferenceSegment_ListElement_default_instance_;
class ReferenceSegment_ListRange;
struct ReferenceSegment_ListRangeDefaultTypeInternal;
extern ReferenceSegment_ListRangeDefaultTypeInternal _ReferenceSegment_ListRange_default_instance_;
class ReferenceSegment_MapKey;
struct ReferenceSegment_MapKeyDefaultTypeInternal;
extern ReferenceSegment_MapKeyDefaultTypeInternal _ReferenceSegment_MapKey_default_instance_;
class ReferenceSegment_MapKeyExpression;
struct ReferenceSegment_MapKeyExpressionDefaultTypeInternal;
extern ReferenceSegment_MapKeyExpressionDefaultTypeInternal _ReferenceSegment_MapKeyExpression_default_instance_;
class ReferenceSegment_StructField;
struct ReferenceSegment_StructFieldDefaultTypeInternal;
extern ReferenceSegment_StructFieldDefaultTypeInternal _ReferenceSegment_StructField_default_instance_;
}  // namespace substrait
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::substrait::FieldReference* Arena::CreateMaybeMessage<::io::substrait::FieldReference>(Arena*);
template<> ::io::substrait::MaskExpression* Arena::CreateMaybeMessage<::io::substrait::MaskExpression>(Arena*);
template<> ::io::substrait::MaskExpression_ListSelect* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_ListSelect>(Arena*);
template<> ::io::substrait::MaskExpression_ListSelect_ListSelectItem* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_ListSelect_ListSelectItem>(Arena*);
template<> ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement>(Arena*);
template<> ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice>(Arena*);
template<> ::io::substrait::MaskExpression_MapSelect* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_MapSelect>(Arena*);
template<> ::io::substrait::MaskExpression_MapSelect_MapKey* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_MapSelect_MapKey>(Arena*);
template<> ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_MapSelect_MapKeyExpression>(Arena*);
template<> ::io::substrait::MaskExpression_Select* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_Select>(Arena*);
template<> ::io::substrait::MaskExpression_StructItem* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_StructItem>(Arena*);
template<> ::io::substrait::MaskExpression_StructSelect* Arena::CreateMaybeMessage<::io::substrait::MaskExpression_StructSelect>(Arena*);
template<> ::io::substrait::ReferenceSegment* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment>(Arena*);
template<> ::io::substrait::ReferenceSegment_ListElement* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment_ListElement>(Arena*);
template<> ::io::substrait::ReferenceSegment_ListRange* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment_ListRange>(Arena*);
template<> ::io::substrait::ReferenceSegment_MapKey* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment_MapKey>(Arena*);
template<> ::io::substrait::ReferenceSegment_MapKeyExpression* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment_MapKeyExpression>(Arena*);
template<> ::io::substrait::ReferenceSegment_StructField* Arena::CreateMaybeMessage<::io::substrait::ReferenceSegment_StructField>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace substrait {

// ===================================================================

class ReferenceSegment_MapKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment.MapKey) */ {
 public:
  inline ReferenceSegment_MapKey() : ReferenceSegment_MapKey(nullptr) {}
  ~ReferenceSegment_MapKey() override;
  explicit constexpr ReferenceSegment_MapKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment_MapKey(const ReferenceSegment_MapKey& from);
  ReferenceSegment_MapKey(ReferenceSegment_MapKey&& from) noexcept
    : ReferenceSegment_MapKey() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment_MapKey& operator=(const ReferenceSegment_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment_MapKey& operator=(ReferenceSegment_MapKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment_MapKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceSegment_MapKey* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment_MapKey*>(
               &_ReferenceSegment_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReferenceSegment_MapKey& a, ReferenceSegment_MapKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment_MapKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment_MapKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment_MapKey* New() const final {
    return CreateMaybeMessage<ReferenceSegment_MapKey>(nullptr);
  }

  ReferenceSegment_MapKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment_MapKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment_MapKey& from);
  void MergeFrom(const ReferenceSegment_MapKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment_MapKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment.MapKey";
  }
  protected:
  explicit ReferenceSegment_MapKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // string map_key = 1;
  void clear_map_key();
  const std::string& map_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key();
  std::string* release_map_key();
  void set_allocated_map_key(std::string* map_key);
  private:
  const std::string& _internal_map_key() const;
  void _internal_set_map_key(const std::string& value);
  std::string* _internal_mutable_map_key();
  public:

  // .io.substrait.ReferenceSegment child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::ReferenceSegment& child() const;
  ::io::substrait::ReferenceSegment* release_child();
  ::io::substrait::ReferenceSegment* mutable_child();
  void set_allocated_child(::io::substrait::ReferenceSegment* child);
  private:
  const ::io::substrait::ReferenceSegment& _internal_child() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::ReferenceSegment* child);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment.MapKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_;
  ::io::substrait::ReferenceSegment* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class ReferenceSegment_MapKeyExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment.MapKeyExpression) */ {
 public:
  inline ReferenceSegment_MapKeyExpression() : ReferenceSegment_MapKeyExpression(nullptr) {}
  ~ReferenceSegment_MapKeyExpression() override;
  explicit constexpr ReferenceSegment_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment_MapKeyExpression(const ReferenceSegment_MapKeyExpression& from);
  ReferenceSegment_MapKeyExpression(ReferenceSegment_MapKeyExpression&& from) noexcept
    : ReferenceSegment_MapKeyExpression() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment_MapKeyExpression& operator=(const ReferenceSegment_MapKeyExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment_MapKeyExpression& operator=(ReferenceSegment_MapKeyExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment_MapKeyExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceSegment_MapKeyExpression* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment_MapKeyExpression*>(
               &_ReferenceSegment_MapKeyExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReferenceSegment_MapKeyExpression& a, ReferenceSegment_MapKeyExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment_MapKeyExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment_MapKeyExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment_MapKeyExpression* New() const final {
    return CreateMaybeMessage<ReferenceSegment_MapKeyExpression>(nullptr);
  }

  ReferenceSegment_MapKeyExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment_MapKeyExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment_MapKeyExpression& from);
  void MergeFrom(const ReferenceSegment_MapKeyExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment_MapKeyExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment.MapKeyExpression";
  }
  protected:
  explicit ReferenceSegment_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyExpressionFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // string map_key_expression = 1;
  void clear_map_key_expression();
  const std::string& map_key_expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key_expression();
  std::string* release_map_key_expression();
  void set_allocated_map_key_expression(std::string* map_key_expression);
  private:
  const std::string& _internal_map_key_expression() const;
  void _internal_set_map_key_expression(const std::string& value);
  std::string* _internal_mutable_map_key_expression();
  public:

  // .io.substrait.ReferenceSegment child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::ReferenceSegment& child() const;
  ::io::substrait::ReferenceSegment* release_child();
  ::io::substrait::ReferenceSegment* mutable_child();
  void set_allocated_child(::io::substrait::ReferenceSegment* child);
  private:
  const ::io::substrait::ReferenceSegment& _internal_child() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::ReferenceSegment* child);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment.MapKeyExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_expression_;
  ::io::substrait::ReferenceSegment* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class ReferenceSegment_StructField PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment.StructField) */ {
 public:
  inline ReferenceSegment_StructField() : ReferenceSegment_StructField(nullptr) {}
  ~ReferenceSegment_StructField() override;
  explicit constexpr ReferenceSegment_StructField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment_StructField(const ReferenceSegment_StructField& from);
  ReferenceSegment_StructField(ReferenceSegment_StructField&& from) noexcept
    : ReferenceSegment_StructField() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment_StructField& operator=(const ReferenceSegment_StructField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment_StructField& operator=(ReferenceSegment_StructField&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment_StructField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceSegment_StructField* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment_StructField*>(
               &_ReferenceSegment_StructField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReferenceSegment_StructField& a, ReferenceSegment_StructField& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment_StructField* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment_StructField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment_StructField* New() const final {
    return CreateMaybeMessage<ReferenceSegment_StructField>(nullptr);
  }

  ReferenceSegment_StructField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment_StructField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment_StructField& from);
  void MergeFrom(const ReferenceSegment_StructField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment_StructField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment.StructField";
  }
  protected:
  explicit ReferenceSegment_StructField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .io.substrait.ReferenceSegment child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::ReferenceSegment& child() const;
  ::io::substrait::ReferenceSegment* release_child();
  ::io::substrait::ReferenceSegment* mutable_child();
  void set_allocated_child(::io::substrait::ReferenceSegment* child);
  private:
  const ::io::substrait::ReferenceSegment& _internal_child() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::ReferenceSegment* child);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_child();

  // int32 field = 1;
  void clear_field();
  ::PROTOBUF_NAMESPACE_ID::int32 field() const;
  void set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field() const;
  void _internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment.StructField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::ReferenceSegment* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class ReferenceSegment_ListElement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment.ListElement) */ {
 public:
  inline ReferenceSegment_ListElement() : ReferenceSegment_ListElement(nullptr) {}
  ~ReferenceSegment_ListElement() override;
  explicit constexpr ReferenceSegment_ListElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment_ListElement(const ReferenceSegment_ListElement& from);
  ReferenceSegment_ListElement(ReferenceSegment_ListElement&& from) noexcept
    : ReferenceSegment_ListElement() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment_ListElement& operator=(const ReferenceSegment_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment_ListElement& operator=(ReferenceSegment_ListElement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment_ListElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceSegment_ListElement* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment_ListElement*>(
               &_ReferenceSegment_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReferenceSegment_ListElement& a, ReferenceSegment_ListElement& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment_ListElement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment_ListElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment_ListElement* New() const final {
    return CreateMaybeMessage<ReferenceSegment_ListElement>(nullptr);
  }

  ReferenceSegment_ListElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment_ListElement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment_ListElement& from);
  void MergeFrom(const ReferenceSegment_ListElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment_ListElement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment.ListElement";
  }
  protected:
  explicit ReferenceSegment_ListElement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kOffsetFieldNumber = 1,
  };
  // .io.substrait.ReferenceSegment child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::ReferenceSegment& child() const;
  ::io::substrait::ReferenceSegment* release_child();
  ::io::substrait::ReferenceSegment* mutable_child();
  void set_allocated_child(::io::substrait::ReferenceSegment* child);
  private:
  const ::io::substrait::ReferenceSegment& _internal_child() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::ReferenceSegment* child);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_child();

  // int32 offset = 1;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment.ListElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::ReferenceSegment* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class ReferenceSegment_ListRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment.ListRange) */ {
 public:
  inline ReferenceSegment_ListRange() : ReferenceSegment_ListRange(nullptr) {}
  ~ReferenceSegment_ListRange() override;
  explicit constexpr ReferenceSegment_ListRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment_ListRange(const ReferenceSegment_ListRange& from);
  ReferenceSegment_ListRange(ReferenceSegment_ListRange&& from) noexcept
    : ReferenceSegment_ListRange() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment_ListRange& operator=(const ReferenceSegment_ListRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment_ListRange& operator=(ReferenceSegment_ListRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment_ListRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceSegment_ListRange* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment_ListRange*>(
               &_ReferenceSegment_ListRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReferenceSegment_ListRange& a, ReferenceSegment_ListRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment_ListRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment_ListRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment_ListRange* New() const final {
    return CreateMaybeMessage<ReferenceSegment_ListRange>(nullptr);
  }

  ReferenceSegment_ListRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment_ListRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment_ListRange& from);
  void MergeFrom(const ReferenceSegment_ListRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment_ListRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment.ListRange";
  }
  protected:
  explicit ReferenceSegment_ListRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 3,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .io.substrait.ReferenceSegment child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::ReferenceSegment& child() const;
  ::io::substrait::ReferenceSegment* release_child();
  ::io::substrait::ReferenceSegment* mutable_child();
  void set_allocated_child(::io::substrait::ReferenceSegment* child);
  private:
  const ::io::substrait::ReferenceSegment& _internal_child() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::ReferenceSegment* child);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_child();

  // int32 start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 end = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment.ListRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::ReferenceSegment* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class ReferenceSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.ReferenceSegment) */ {
 public:
  inline ReferenceSegment() : ReferenceSegment(nullptr) {}
  ~ReferenceSegment() override;
  explicit constexpr ReferenceSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceSegment(const ReferenceSegment& from);
  ReferenceSegment(ReferenceSegment&& from) noexcept
    : ReferenceSegment() {
    *this = ::std::move(from);
  }

  inline ReferenceSegment& operator=(const ReferenceSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceSegment& operator=(ReferenceSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceSegment& default_instance() {
    return *internal_default_instance();
  }
  enum ReferenceTypeCase {
    kMapKey = 1,
    kExpression = 2,
    kStructField = 3,
    kListElement = 4,
    kListRange = 5,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  static inline const ReferenceSegment* internal_default_instance() {
    return reinterpret_cast<const ReferenceSegment*>(
               &_ReferenceSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReferenceSegment& a, ReferenceSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceSegment* New() const final {
    return CreateMaybeMessage<ReferenceSegment>(nullptr);
  }

  ReferenceSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceSegment& from);
  void MergeFrom(const ReferenceSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.ReferenceSegment";
  }
  protected:
  explicit ReferenceSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReferenceSegment_MapKey MapKey;
  typedef ReferenceSegment_MapKeyExpression MapKeyExpression;
  typedef ReferenceSegment_StructField StructField;
  typedef ReferenceSegment_ListElement ListElement;
  typedef ReferenceSegment_ListRange ListRange;

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
    kExpressionFieldNumber = 2,
    kStructFieldFieldNumber = 3,
    kListElementFieldNumber = 4,
    kListRangeFieldNumber = 5,
  };
  // .io.substrait.ReferenceSegment.MapKey map_key = 1;
  bool has_map_key() const;
  private:
  bool _internal_has_map_key() const;
  public:
  void clear_map_key();
  const ::io::substrait::ReferenceSegment_MapKey& map_key() const;
  ::io::substrait::ReferenceSegment_MapKey* release_map_key();
  ::io::substrait::ReferenceSegment_MapKey* mutable_map_key();
  void set_allocated_map_key(::io::substrait::ReferenceSegment_MapKey* map_key);
  private:
  const ::io::substrait::ReferenceSegment_MapKey& _internal_map_key() const;
  ::io::substrait::ReferenceSegment_MapKey* _internal_mutable_map_key();
  public:
  void unsafe_arena_set_allocated_map_key(
      ::io::substrait::ReferenceSegment_MapKey* map_key);
  ::io::substrait::ReferenceSegment_MapKey* unsafe_arena_release_map_key();

  // .io.substrait.ReferenceSegment.MapKeyExpression expression = 2;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::io::substrait::ReferenceSegment_MapKeyExpression& expression() const;
  ::io::substrait::ReferenceSegment_MapKeyExpression* release_expression();
  ::io::substrait::ReferenceSegment_MapKeyExpression* mutable_expression();
  void set_allocated_expression(::io::substrait::ReferenceSegment_MapKeyExpression* expression);
  private:
  const ::io::substrait::ReferenceSegment_MapKeyExpression& _internal_expression() const;
  ::io::substrait::ReferenceSegment_MapKeyExpression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::io::substrait::ReferenceSegment_MapKeyExpression* expression);
  ::io::substrait::ReferenceSegment_MapKeyExpression* unsafe_arena_release_expression();

  // .io.substrait.ReferenceSegment.StructField struct_field = 3;
  bool has_struct_field() const;
  private:
  bool _internal_has_struct_field() const;
  public:
  void clear_struct_field();
  const ::io::substrait::ReferenceSegment_StructField& struct_field() const;
  ::io::substrait::ReferenceSegment_StructField* release_struct_field();
  ::io::substrait::ReferenceSegment_StructField* mutable_struct_field();
  void set_allocated_struct_field(::io::substrait::ReferenceSegment_StructField* struct_field);
  private:
  const ::io::substrait::ReferenceSegment_StructField& _internal_struct_field() const;
  ::io::substrait::ReferenceSegment_StructField* _internal_mutable_struct_field();
  public:
  void unsafe_arena_set_allocated_struct_field(
      ::io::substrait::ReferenceSegment_StructField* struct_field);
  ::io::substrait::ReferenceSegment_StructField* unsafe_arena_release_struct_field();

  // .io.substrait.ReferenceSegment.ListElement list_element = 4;
  bool has_list_element() const;
  private:
  bool _internal_has_list_element() const;
  public:
  void clear_list_element();
  const ::io::substrait::ReferenceSegment_ListElement& list_element() const;
  ::io::substrait::ReferenceSegment_ListElement* release_list_element();
  ::io::substrait::ReferenceSegment_ListElement* mutable_list_element();
  void set_allocated_list_element(::io::substrait::ReferenceSegment_ListElement* list_element);
  private:
  const ::io::substrait::ReferenceSegment_ListElement& _internal_list_element() const;
  ::io::substrait::ReferenceSegment_ListElement* _internal_mutable_list_element();
  public:
  void unsafe_arena_set_allocated_list_element(
      ::io::substrait::ReferenceSegment_ListElement* list_element);
  ::io::substrait::ReferenceSegment_ListElement* unsafe_arena_release_list_element();

  // .io.substrait.ReferenceSegment.ListRange list_range = 5;
  bool has_list_range() const;
  private:
  bool _internal_has_list_range() const;
  public:
  void clear_list_range();
  const ::io::substrait::ReferenceSegment_ListRange& list_range() const;
  ::io::substrait::ReferenceSegment_ListRange* release_list_range();
  ::io::substrait::ReferenceSegment_ListRange* mutable_list_range();
  void set_allocated_list_range(::io::substrait::ReferenceSegment_ListRange* list_range);
  private:
  const ::io::substrait::ReferenceSegment_ListRange& _internal_list_range() const;
  ::io::substrait::ReferenceSegment_ListRange* _internal_mutable_list_range();
  public:
  void unsafe_arena_set_allocated_list_range(
      ::io::substrait::ReferenceSegment_ListRange* list_range);
  ::io::substrait::ReferenceSegment_ListRange* unsafe_arena_release_list_range();

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  // @@protoc_insertion_point(class_scope:io.substrait.ReferenceSegment)
 private:
  class _Internal;
  void set_has_map_key();
  void set_has_expression();
  void set_has_struct_field();
  void set_has_list_element();
  void set_has_list_range();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReferenceTypeUnion {
    constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::substrait::ReferenceSegment_MapKey* map_key_;
    ::io::substrait::ReferenceSegment_MapKeyExpression* expression_;
    ::io::substrait::ReferenceSegment_StructField* struct_field_;
    ::io::substrait::ReferenceSegment_ListElement* list_element_;
    ::io::substrait::ReferenceSegment_ListRange* list_range_;
  } reference_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_Select PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.Select) */ {
 public:
  inline MaskExpression_Select() : MaskExpression_Select(nullptr) {}
  ~MaskExpression_Select() override;
  explicit constexpr MaskExpression_Select(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_Select(const MaskExpression_Select& from);
  MaskExpression_Select(MaskExpression_Select&& from) noexcept
    : MaskExpression_Select() {
    *this = ::std::move(from);
  }

  inline MaskExpression_Select& operator=(const MaskExpression_Select& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_Select& operator=(MaskExpression_Select&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_Select& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kStruct = 1,
    kList = 2,
    kMap = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const MaskExpression_Select* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_Select*>(
               &_MaskExpression_Select_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MaskExpression_Select& a, MaskExpression_Select& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_Select* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_Select* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_Select* New() const final {
    return CreateMaybeMessage<MaskExpression_Select>(nullptr);
  }

  MaskExpression_Select* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_Select>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_Select& from);
  void MergeFrom(const MaskExpression_Select& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_Select* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.Select";
  }
  protected:
  explicit MaskExpression_Select(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructFieldNumber = 1,
    kListFieldNumber = 2,
    kMapFieldNumber = 3,
  };
  // .io.substrait.MaskExpression.StructSelect struct = 1;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::io::substrait::MaskExpression_StructSelect& struct_() const;
  ::io::substrait::MaskExpression_StructSelect* release_struct_();
  ::io::substrait::MaskExpression_StructSelect* mutable_struct_();
  void set_allocated_struct_(::io::substrait::MaskExpression_StructSelect* struct_);
  private:
  const ::io::substrait::MaskExpression_StructSelect& _internal_struct_() const;
  ::io::substrait::MaskExpression_StructSelect* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::io::substrait::MaskExpression_StructSelect* struct_);
  ::io::substrait::MaskExpression_StructSelect* unsafe_arena_release_struct_();

  // .io.substrait.MaskExpression.ListSelect list = 2;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::io::substrait::MaskExpression_ListSelect& list() const;
  ::io::substrait::MaskExpression_ListSelect* release_list();
  ::io::substrait::MaskExpression_ListSelect* mutable_list();
  void set_allocated_list(::io::substrait::MaskExpression_ListSelect* list);
  private:
  const ::io::substrait::MaskExpression_ListSelect& _internal_list() const;
  ::io::substrait::MaskExpression_ListSelect* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::io::substrait::MaskExpression_ListSelect* list);
  ::io::substrait::MaskExpression_ListSelect* unsafe_arena_release_list();

  // .io.substrait.MaskExpression.MapSelect map = 3;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::io::substrait::MaskExpression_MapSelect& map() const;
  ::io::substrait::MaskExpression_MapSelect* release_map();
  ::io::substrait::MaskExpression_MapSelect* mutable_map();
  void set_allocated_map(::io::substrait::MaskExpression_MapSelect* map);
  private:
  const ::io::substrait::MaskExpression_MapSelect& _internal_map() const;
  ::io::substrait::MaskExpression_MapSelect* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::io::substrait::MaskExpression_MapSelect* map);
  ::io::substrait::MaskExpression_MapSelect* unsafe_arena_release_map();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.Select)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_list();
  void set_has_map();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::substrait::MaskExpression_StructSelect* struct__;
    ::io::substrait::MaskExpression_ListSelect* list_;
    ::io::substrait::MaskExpression_MapSelect* map_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_StructSelect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.StructSelect) */ {
 public:
  inline MaskExpression_StructSelect() : MaskExpression_StructSelect(nullptr) {}
  ~MaskExpression_StructSelect() override;
  explicit constexpr MaskExpression_StructSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_StructSelect(const MaskExpression_StructSelect& from);
  MaskExpression_StructSelect(MaskExpression_StructSelect&& from) noexcept
    : MaskExpression_StructSelect() {
    *this = ::std::move(from);
  }

  inline MaskExpression_StructSelect& operator=(const MaskExpression_StructSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_StructSelect& operator=(MaskExpression_StructSelect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_StructSelect& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_StructSelect* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_StructSelect*>(
               &_MaskExpression_StructSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MaskExpression_StructSelect& a, MaskExpression_StructSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_StructSelect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_StructSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_StructSelect* New() const final {
    return CreateMaybeMessage<MaskExpression_StructSelect>(nullptr);
  }

  MaskExpression_StructSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_StructSelect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_StructSelect& from);
  void MergeFrom(const MaskExpression_StructSelect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_StructSelect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.StructSelect";
  }
  protected:
  explicit MaskExpression_StructSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructItemsFieldNumber = 1,
  };
  // repeated .io.substrait.MaskExpression.StructItem struct_items = 1;
  int struct_items_size() const;
  private:
  int _internal_struct_items_size() const;
  public:
  void clear_struct_items();
  ::io::substrait::MaskExpression_StructItem* mutable_struct_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_StructItem >*
      mutable_struct_items();
  private:
  const ::io::substrait::MaskExpression_StructItem& _internal_struct_items(int index) const;
  ::io::substrait::MaskExpression_StructItem* _internal_add_struct_items();
  public:
  const ::io::substrait::MaskExpression_StructItem& struct_items(int index) const;
  ::io::substrait::MaskExpression_StructItem* add_struct_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_StructItem >&
      struct_items() const;

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.StructSelect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_StructItem > struct_items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_StructItem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.StructItem) */ {
 public:
  inline MaskExpression_StructItem() : MaskExpression_StructItem(nullptr) {}
  ~MaskExpression_StructItem() override;
  explicit constexpr MaskExpression_StructItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_StructItem(const MaskExpression_StructItem& from);
  MaskExpression_StructItem(MaskExpression_StructItem&& from) noexcept
    : MaskExpression_StructItem() {
    *this = ::std::move(from);
  }

  inline MaskExpression_StructItem& operator=(const MaskExpression_StructItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_StructItem& operator=(MaskExpression_StructItem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_StructItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_StructItem* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_StructItem*>(
               &_MaskExpression_StructItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MaskExpression_StructItem& a, MaskExpression_StructItem& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_StructItem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_StructItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_StructItem* New() const final {
    return CreateMaybeMessage<MaskExpression_StructItem>(nullptr);
  }

  MaskExpression_StructItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_StructItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_StructItem& from);
  void MergeFrom(const MaskExpression_StructItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_StructItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.StructItem";
  }
  protected:
  explicit MaskExpression_StructItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .io.substrait.MaskExpression.Select child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::MaskExpression_Select& child() const;
  ::io::substrait::MaskExpression_Select* release_child();
  ::io::substrait::MaskExpression_Select* mutable_child();
  void set_allocated_child(::io::substrait::MaskExpression_Select* child);
  private:
  const ::io::substrait::MaskExpression_Select& _internal_child() const;
  ::io::substrait::MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::MaskExpression_Select* child);
  ::io::substrait::MaskExpression_Select* unsafe_arena_release_child();

  // int32 field = 1;
  void clear_field();
  ::PROTOBUF_NAMESPACE_ID::int32 field() const;
  void set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field() const;
  void _internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.StructItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::MaskExpression_Select* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_ListSelect_ListSelectItem_ListElement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement) */ {
 public:
  inline MaskExpression_ListSelect_ListSelectItem_ListElement() : MaskExpression_ListSelect_ListSelectItem_ListElement(nullptr) {}
  ~MaskExpression_ListSelect_ListSelectItem_ListElement() override;
  explicit constexpr MaskExpression_ListSelect_ListSelectItem_ListElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_ListSelect_ListSelectItem_ListElement(const MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  MaskExpression_ListSelect_ListSelectItem_ListElement(MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept
    : MaskExpression_ListSelect_ListSelectItem_ListElement() {
    *this = ::std::move(from);
  }

  inline MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(const MaskExpression_ListSelect_ListSelectItem_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_ListSelect_ListSelectItem_ListElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_ListSelect_ListSelectItem_ListElement* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_ListSelect_ListSelectItem_ListElement*>(
               &_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MaskExpression_ListSelect_ListSelectItem_ListElement& a, MaskExpression_ListSelect_ListSelectItem_ListElement& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_ListSelect_ListSelectItem_ListElement* New() const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem_ListElement>(nullptr);
  }

  MaskExpression_ListSelect_ListSelectItem_ListElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem_ListElement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  void MergeFrom(const MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_ListSelect_ListSelectItem_ListElement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement";
  }
  protected:
  explicit MaskExpression_ListSelect_ListSelectItem_ListElement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // int32 field = 1;
  void clear_field();
  ::PROTOBUF_NAMESPACE_ID::int32 field() const;
  void set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field() const;
  void _internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_ListSelect_ListSelectItem_ListSlice PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice) */ {
 public:
  inline MaskExpression_ListSelect_ListSelectItem_ListSlice() : MaskExpression_ListSelect_ListSelectItem_ListSlice(nullptr) {}
  ~MaskExpression_ListSelect_ListSelectItem_ListSlice() override;
  explicit constexpr MaskExpression_ListSelect_ListSelectItem_ListSlice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_ListSelect_ListSelectItem_ListSlice(const MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  MaskExpression_ListSelect_ListSelectItem_ListSlice(MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept
    : MaskExpression_ListSelect_ListSelectItem_ListSlice() {
    *this = ::std::move(from);
  }

  inline MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(const MaskExpression_ListSelect_ListSelectItem_ListSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_ListSelect_ListSelectItem_ListSlice& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_ListSelect_ListSelectItem_ListSlice* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_ListSelect_ListSelectItem_ListSlice*>(
               &_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MaskExpression_ListSelect_ListSelectItem_ListSlice& a, MaskExpression_ListSelect_ListSelectItem_ListSlice& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_ListSelect_ListSelectItem_ListSlice* New() const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem_ListSlice>(nullptr);
  }

  MaskExpression_ListSelect_ListSelectItem_ListSlice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem_ListSlice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  void MergeFrom(const MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_ListSelect_ListSelectItem_ListSlice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice";
  }
  protected:
  explicit MaskExpression_ListSelect_ListSelectItem_ListSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int32 start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 end = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_ListSelect_ListSelectItem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.ListSelect.ListSelectItem) */ {
 public:
  inline MaskExpression_ListSelect_ListSelectItem() : MaskExpression_ListSelect_ListSelectItem(nullptr) {}
  ~MaskExpression_ListSelect_ListSelectItem() override;
  explicit constexpr MaskExpression_ListSelect_ListSelectItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_ListSelect_ListSelectItem(const MaskExpression_ListSelect_ListSelectItem& from);
  MaskExpression_ListSelect_ListSelectItem(MaskExpression_ListSelect_ListSelectItem&& from) noexcept
    : MaskExpression_ListSelect_ListSelectItem() {
    *this = ::std::move(from);
  }

  inline MaskExpression_ListSelect_ListSelectItem& operator=(const MaskExpression_ListSelect_ListSelectItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_ListSelect_ListSelectItem& operator=(MaskExpression_ListSelect_ListSelectItem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_ListSelect_ListSelectItem& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kItem = 1,
    kSlice = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const MaskExpression_ListSelect_ListSelectItem* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_ListSelect_ListSelectItem*>(
               &_MaskExpression_ListSelect_ListSelectItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MaskExpression_ListSelect_ListSelectItem& a, MaskExpression_ListSelect_ListSelectItem& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_ListSelect_ListSelectItem* New() const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem>(nullptr);
  }

  MaskExpression_ListSelect_ListSelectItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_ListSelect_ListSelectItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_ListSelect_ListSelectItem& from);
  void MergeFrom(const MaskExpression_ListSelect_ListSelectItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_ListSelect_ListSelectItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.ListSelect.ListSelectItem";
  }
  protected:
  explicit MaskExpression_ListSelect_ListSelectItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MaskExpression_ListSelect_ListSelectItem_ListElement ListElement;
  typedef MaskExpression_ListSelect_ListSelectItem_ListSlice ListSlice;

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kSliceFieldNumber = 2,
  };
  // .io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement& item() const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* release_item();
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* mutable_item();
  void set_allocated_item(::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* item);
  private:
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement& _internal_item() const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* item);
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* unsafe_arena_release_item();

  // .io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;
  public:
  void clear_slice();
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice& slice() const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* release_slice();
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* mutable_slice();
  void set_allocated_slice(::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* slice);
  private:
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice& _internal_slice() const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* _internal_mutable_slice();
  public:
  void unsafe_arena_set_allocated_slice(
      ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* slice);
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* unsafe_arena_release_slice();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.ListSelect.ListSelectItem)
 private:
  class _Internal;
  void set_has_item();
  void set_has_slice();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* item_;
    ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* slice_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_ListSelect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.ListSelect) */ {
 public:
  inline MaskExpression_ListSelect() : MaskExpression_ListSelect(nullptr) {}
  ~MaskExpression_ListSelect() override;
  explicit constexpr MaskExpression_ListSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_ListSelect(const MaskExpression_ListSelect& from);
  MaskExpression_ListSelect(MaskExpression_ListSelect&& from) noexcept
    : MaskExpression_ListSelect() {
    *this = ::std::move(from);
  }

  inline MaskExpression_ListSelect& operator=(const MaskExpression_ListSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_ListSelect& operator=(MaskExpression_ListSelect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_ListSelect& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_ListSelect* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_ListSelect*>(
               &_MaskExpression_ListSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MaskExpression_ListSelect& a, MaskExpression_ListSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_ListSelect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_ListSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_ListSelect* New() const final {
    return CreateMaybeMessage<MaskExpression_ListSelect>(nullptr);
  }

  MaskExpression_ListSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_ListSelect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_ListSelect& from);
  void MergeFrom(const MaskExpression_ListSelect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_ListSelect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.ListSelect";
  }
  protected:
  explicit MaskExpression_ListSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MaskExpression_ListSelect_ListSelectItem ListSelectItem;

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // repeated .io.substrait.MaskExpression.ListSelect.ListSelectItem selection = 1;
  int selection_size() const;
  private:
  int _internal_selection_size() const;
  public:
  void clear_selection();
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem* mutable_selection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_ListSelect_ListSelectItem >*
      mutable_selection();
  private:
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem& _internal_selection(int index) const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem* _internal_add_selection();
  public:
  const ::io::substrait::MaskExpression_ListSelect_ListSelectItem& selection(int index) const;
  ::io::substrait::MaskExpression_ListSelect_ListSelectItem* add_selection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_ListSelect_ListSelectItem >&
      selection() const;

  // .io.substrait.MaskExpression.Select child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::MaskExpression_Select& child() const;
  ::io::substrait::MaskExpression_Select* release_child();
  ::io::substrait::MaskExpression_Select* mutable_child();
  void set_allocated_child(::io::substrait::MaskExpression_Select* child);
  private:
  const ::io::substrait::MaskExpression_Select& _internal_child() const;
  ::io::substrait::MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::MaskExpression_Select* child);
  ::io::substrait::MaskExpression_Select* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.ListSelect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_ListSelect_ListSelectItem > selection_;
  ::io::substrait::MaskExpression_Select* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_MapSelect_MapKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.MapSelect.MapKey) */ {
 public:
  inline MaskExpression_MapSelect_MapKey() : MaskExpression_MapSelect_MapKey(nullptr) {}
  ~MaskExpression_MapSelect_MapKey() override;
  explicit constexpr MaskExpression_MapSelect_MapKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_MapSelect_MapKey(const MaskExpression_MapSelect_MapKey& from);
  MaskExpression_MapSelect_MapKey(MaskExpression_MapSelect_MapKey&& from) noexcept
    : MaskExpression_MapSelect_MapKey() {
    *this = ::std::move(from);
  }

  inline MaskExpression_MapSelect_MapKey& operator=(const MaskExpression_MapSelect_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_MapSelect_MapKey& operator=(MaskExpression_MapSelect_MapKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_MapSelect_MapKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_MapSelect_MapKey* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_MapSelect_MapKey*>(
               &_MaskExpression_MapSelect_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MaskExpression_MapSelect_MapKey& a, MaskExpression_MapSelect_MapKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_MapSelect_MapKey* New() const final {
    return CreateMaybeMessage<MaskExpression_MapSelect_MapKey>(nullptr);
  }

  MaskExpression_MapSelect_MapKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_MapSelect_MapKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_MapSelect_MapKey& from);
  void MergeFrom(const MaskExpression_MapSelect_MapKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_MapSelect_MapKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.MapSelect.MapKey";
  }
  protected:
  explicit MaskExpression_MapSelect_MapKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
  };
  // string map_key = 1;
  void clear_map_key();
  const std::string& map_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key();
  std::string* release_map_key();
  void set_allocated_map_key(std::string* map_key);
  private:
  const std::string& _internal_map_key() const;
  void _internal_set_map_key(const std::string& value);
  std::string* _internal_mutable_map_key();
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.MapSelect.MapKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_MapSelect_MapKeyExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.MapSelect.MapKeyExpression) */ {
 public:
  inline MaskExpression_MapSelect_MapKeyExpression() : MaskExpression_MapSelect_MapKeyExpression(nullptr) {}
  ~MaskExpression_MapSelect_MapKeyExpression() override;
  explicit constexpr MaskExpression_MapSelect_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_MapSelect_MapKeyExpression(const MaskExpression_MapSelect_MapKeyExpression& from);
  MaskExpression_MapSelect_MapKeyExpression(MaskExpression_MapSelect_MapKeyExpression&& from) noexcept
    : MaskExpression_MapSelect_MapKeyExpression() {
    *this = ::std::move(from);
  }

  inline MaskExpression_MapSelect_MapKeyExpression& operator=(const MaskExpression_MapSelect_MapKeyExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_MapSelect_MapKeyExpression& operator=(MaskExpression_MapSelect_MapKeyExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_MapSelect_MapKeyExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression_MapSelect_MapKeyExpression* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_MapSelect_MapKeyExpression*>(
               &_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MaskExpression_MapSelect_MapKeyExpression& a, MaskExpression_MapSelect_MapKeyExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_MapSelect_MapKeyExpression* New() const final {
    return CreateMaybeMessage<MaskExpression_MapSelect_MapKeyExpression>(nullptr);
  }

  MaskExpression_MapSelect_MapKeyExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_MapSelect_MapKeyExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_MapSelect_MapKeyExpression& from);
  void MergeFrom(const MaskExpression_MapSelect_MapKeyExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_MapSelect_MapKeyExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.MapSelect.MapKeyExpression";
  }
  protected:
  explicit MaskExpression_MapSelect_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyExpressionFieldNumber = 1,
  };
  // string map_key_expression = 1;
  void clear_map_key_expression();
  const std::string& map_key_expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key_expression();
  std::string* release_map_key_expression();
  void set_allocated_map_key_expression(std::string* map_key_expression);
  private:
  const std::string& _internal_map_key_expression() const;
  void _internal_set_map_key_expression(const std::string& value);
  std::string* _internal_mutable_map_key_expression();
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.MapSelect.MapKeyExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_expression_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression_MapSelect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression.MapSelect) */ {
 public:
  inline MaskExpression_MapSelect() : MaskExpression_MapSelect(nullptr) {}
  ~MaskExpression_MapSelect() override;
  explicit constexpr MaskExpression_MapSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression_MapSelect(const MaskExpression_MapSelect& from);
  MaskExpression_MapSelect(MaskExpression_MapSelect&& from) noexcept
    : MaskExpression_MapSelect() {
    *this = ::std::move(from);
  }

  inline MaskExpression_MapSelect& operator=(const MaskExpression_MapSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression_MapSelect& operator=(MaskExpression_MapSelect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression_MapSelect& default_instance() {
    return *internal_default_instance();
  }
  enum SelectCase {
    kKey = 1,
    kExpression = 2,
    SELECT_NOT_SET = 0,
  };

  static inline const MaskExpression_MapSelect* internal_default_instance() {
    return reinterpret_cast<const MaskExpression_MapSelect*>(
               &_MaskExpression_MapSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MaskExpression_MapSelect& a, MaskExpression_MapSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression_MapSelect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression_MapSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression_MapSelect* New() const final {
    return CreateMaybeMessage<MaskExpression_MapSelect>(nullptr);
  }

  MaskExpression_MapSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression_MapSelect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression_MapSelect& from);
  void MergeFrom(const MaskExpression_MapSelect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression_MapSelect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression.MapSelect";
  }
  protected:
  explicit MaskExpression_MapSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MaskExpression_MapSelect_MapKey MapKey;
  typedef MaskExpression_MapSelect_MapKeyExpression MapKeyExpression;

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 3,
    kKeyFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // .io.substrait.MaskExpression.Select child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::io::substrait::MaskExpression_Select& child() const;
  ::io::substrait::MaskExpression_Select* release_child();
  ::io::substrait::MaskExpression_Select* mutable_child();
  void set_allocated_child(::io::substrait::MaskExpression_Select* child);
  private:
  const ::io::substrait::MaskExpression_Select& _internal_child() const;
  ::io::substrait::MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::io::substrait::MaskExpression_Select* child);
  ::io::substrait::MaskExpression_Select* unsafe_arena_release_child();

  // .io.substrait.MaskExpression.MapSelect.MapKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::io::substrait::MaskExpression_MapSelect_MapKey& key() const;
  ::io::substrait::MaskExpression_MapSelect_MapKey* release_key();
  ::io::substrait::MaskExpression_MapSelect_MapKey* mutable_key();
  void set_allocated_key(::io::substrait::MaskExpression_MapSelect_MapKey* key);
  private:
  const ::io::substrait::MaskExpression_MapSelect_MapKey& _internal_key() const;
  ::io::substrait::MaskExpression_MapSelect_MapKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::io::substrait::MaskExpression_MapSelect_MapKey* key);
  ::io::substrait::MaskExpression_MapSelect_MapKey* unsafe_arena_release_key();

  // .io.substrait.MaskExpression.MapSelect.MapKeyExpression expression = 2;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::io::substrait::MaskExpression_MapSelect_MapKeyExpression& expression() const;
  ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* release_expression();
  ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* mutable_expression();
  void set_allocated_expression(::io::substrait::MaskExpression_MapSelect_MapKeyExpression* expression);
  private:
  const ::io::substrait::MaskExpression_MapSelect_MapKeyExpression& _internal_expression() const;
  ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* expression);
  ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* unsafe_arena_release_expression();

  void clear_select();
  SelectCase select_case() const;
  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression.MapSelect)
 private:
  class _Internal;
  void set_has_key();
  void set_has_expression();

  inline bool has_select() const;
  inline void clear_has_select();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::MaskExpression_Select* child_;
  union SelectUnion {
    constexpr SelectUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::substrait::MaskExpression_MapSelect_MapKey* key_;
    ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* expression_;
  } select_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class MaskExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.MaskExpression) */ {
 public:
  inline MaskExpression() : MaskExpression(nullptr) {}
  ~MaskExpression() override;
  explicit constexpr MaskExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskExpression(const MaskExpression& from);
  MaskExpression(MaskExpression&& from) noexcept
    : MaskExpression() {
    *this = ::std::move(from);
  }

  inline MaskExpression& operator=(const MaskExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskExpression& operator=(MaskExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskExpression* internal_default_instance() {
    return reinterpret_cast<const MaskExpression*>(
               &_MaskExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MaskExpression& a, MaskExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaskExpression* New() const final {
    return CreateMaybeMessage<MaskExpression>(nullptr);
  }

  MaskExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaskExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaskExpression& from);
  void MergeFrom(const MaskExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.MaskExpression";
  }
  protected:
  explicit MaskExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MaskExpression_Select Select;
  typedef MaskExpression_StructSelect StructSelect;
  typedef MaskExpression_StructItem StructItem;
  typedef MaskExpression_ListSelect ListSelect;
  typedef MaskExpression_MapSelect MapSelect;

  // accessors -------------------------------------------------------

  enum : int {
    kSelectFieldNumber = 1,
    kMaintainSingularStructFieldNumber = 2,
  };
  // .io.substrait.MaskExpression.StructSelect select = 1;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::io::substrait::MaskExpression_StructSelect& select() const;
  ::io::substrait::MaskExpression_StructSelect* release_select();
  ::io::substrait::MaskExpression_StructSelect* mutable_select();
  void set_allocated_select(::io::substrait::MaskExpression_StructSelect* select);
  private:
  const ::io::substrait::MaskExpression_StructSelect& _internal_select() const;
  ::io::substrait::MaskExpression_StructSelect* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::io::substrait::MaskExpression_StructSelect* select);
  ::io::substrait::MaskExpression_StructSelect* unsafe_arena_release_select();

  // bool maintain_singular_struct = 2;
  void clear_maintain_singular_struct();
  bool maintain_singular_struct() const;
  void set_maintain_singular_struct(bool value);
  private:
  bool _internal_maintain_singular_struct() const;
  void _internal_set_maintain_singular_struct(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.substrait.MaskExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::substrait::MaskExpression_StructSelect* select_;
  bool maintain_singular_struct_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_selection_2eproto;
};
// -------------------------------------------------------------------

class FieldReference PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.substrait.FieldReference) */ {
 public:
  inline FieldReference() : FieldReference(nullptr) {}
  ~FieldReference() override;
  explicit constexpr FieldReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldReference(const FieldReference& from);
  FieldReference(FieldReference&& from) noexcept
    : FieldReference() {
    *this = ::std::move(from);
  }

  inline FieldReference& operator=(const FieldReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldReference& operator=(FieldReference&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldReference& default_instance() {
    return *internal_default_instance();
  }
  enum ReferenceTypeCase {
    kDirectReference = 1,
    kMaskedReference = 2,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  static inline const FieldReference* internal_default_instance() {
    return reinterpret_cast<const FieldReference*>(
               &_FieldReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FieldReference& a, FieldReference& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldReference* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldReference* New() const final {
    return CreateMaybeMessage<FieldReference>(nullptr);
  }

  FieldReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldReference>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FieldReference& from);
  void MergeFrom(const FieldReference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.substrait.FieldReference";
  }
  protected:
  explicit FieldReference(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectReferenceFieldNumber = 1,
    kMaskedReferenceFieldNumber = 2,
  };
  // .io.substrait.ReferenceSegment direct_reference = 1;
  bool has_direct_reference() const;
  private:
  bool _internal_has_direct_reference() const;
  public:
  void clear_direct_reference();
  const ::io::substrait::ReferenceSegment& direct_reference() const;
  ::io::substrait::ReferenceSegment* release_direct_reference();
  ::io::substrait::ReferenceSegment* mutable_direct_reference();
  void set_allocated_direct_reference(::io::substrait::ReferenceSegment* direct_reference);
  private:
  const ::io::substrait::ReferenceSegment& _internal_direct_reference() const;
  ::io::substrait::ReferenceSegment* _internal_mutable_direct_reference();
  public:
  void unsafe_arena_set_allocated_direct_reference(
      ::io::substrait::ReferenceSegment* direct_reference);
  ::io::substrait::ReferenceSegment* unsafe_arena_release_direct_reference();

  // .io.substrait.MaskExpression masked_reference = 2;
  bool has_masked_reference() const;
  private:
  bool _internal_has_masked_reference() const;
  public:
  void clear_masked_reference();
  const ::io::substrait::MaskExpression& masked_reference() const;
  ::io::substrait::MaskExpression* release_masked_reference();
  ::io::substrait::MaskExpression* mutable_masked_reference();
  void set_allocated_masked_reference(::io::substrait::MaskExpression* masked_reference);
  private:
  const ::io::substrait::MaskExpression& _internal_masked_reference() const;
  ::io::substrait::MaskExpression* _internal_mutable_masked_reference();
  public:
  void unsafe_arena_set_allocated_masked_reference(
      ::io::substrait::MaskExpression* masked_reference);
  ::io::substrait::MaskExpression* unsafe_arena_release_masked_reference();

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  // @@protoc_insertion_point(class_scope:io.substrait.FieldReference)
 private:
  class _Internal;
  void set_has_direct_reference();
  void set_has_masked_reference();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReferenceTypeUnion {
    constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::substrait::ReferenceSegment* direct_reference_;
    ::io::substrait::MaskExpression* masked_reference_;
  } reference_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_selection_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReferenceSegment_MapKey

// string map_key = 1;
inline void ReferenceSegment_MapKey::clear_map_key() {
  map_key_.ClearToEmpty();
}
inline const std::string& ReferenceSegment_MapKey::map_key() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.MapKey.map_key)
  return _internal_map_key();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ReferenceSegment_MapKey::set_map_key(ArgT0&& arg0, ArgT... args) {
 
 map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.MapKey.map_key)
}
inline std::string* ReferenceSegment_MapKey::mutable_map_key() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.MapKey.map_key)
  return _internal_mutable_map_key();
}
inline const std::string& ReferenceSegment_MapKey::_internal_map_key() const {
  return map_key_.Get();
}
inline void ReferenceSegment_MapKey::_internal_set_map_key(const std::string& value) {
  
  map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ReferenceSegment_MapKey::_internal_mutable_map_key() {
  
  return map_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ReferenceSegment_MapKey::release_map_key() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.MapKey.map_key)
  return map_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReferenceSegment_MapKey::set_allocated_map_key(std::string* map_key) {
  if (map_key != nullptr) {
    
  } else {
    
  }
  map_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.MapKey.map_key)
}

// .io.substrait.ReferenceSegment child = 2;
inline bool ReferenceSegment_MapKey::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ReferenceSegment_MapKey::has_child() const {
  return _internal_has_child();
}
inline void ReferenceSegment_MapKey::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_MapKey::_internal_child() const {
  const ::io::substrait::ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::ReferenceSegment&>(
      ::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_MapKey::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.MapKey.child)
  return _internal_child();
}
inline void ReferenceSegment_MapKey::unsafe_arena_set_allocated_child(
    ::io::substrait::ReferenceSegment* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.MapKey.child)
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKey::release_child() {
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKey::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.MapKey.child)
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKey::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::ReferenceSegment>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKey::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.MapKey.child)
  return _internal_mutable_child();
}
inline void ReferenceSegment_MapKey::set_allocated_child(::io::substrait::ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.MapKey.child)
}

// -------------------------------------------------------------------

// ReferenceSegment_MapKeyExpression

// string map_key_expression = 1;
inline void ReferenceSegment_MapKeyExpression::clear_map_key_expression() {
  map_key_expression_.ClearToEmpty();
}
inline const std::string& ReferenceSegment_MapKeyExpression::map_key_expression() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.MapKeyExpression.map_key_expression)
  return _internal_map_key_expression();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ReferenceSegment_MapKeyExpression::set_map_key_expression(ArgT0&& arg0, ArgT... args) {
 
 map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.MapKeyExpression.map_key_expression)
}
inline std::string* ReferenceSegment_MapKeyExpression::mutable_map_key_expression() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.MapKeyExpression.map_key_expression)
  return _internal_mutable_map_key_expression();
}
inline const std::string& ReferenceSegment_MapKeyExpression::_internal_map_key_expression() const {
  return map_key_expression_.Get();
}
inline void ReferenceSegment_MapKeyExpression::_internal_set_map_key_expression(const std::string& value) {
  
  map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ReferenceSegment_MapKeyExpression::_internal_mutable_map_key_expression() {
  
  return map_key_expression_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ReferenceSegment_MapKeyExpression::release_map_key_expression() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.MapKeyExpression.map_key_expression)
  return map_key_expression_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReferenceSegment_MapKeyExpression::set_allocated_map_key_expression(std::string* map_key_expression) {
  if (map_key_expression != nullptr) {
    
  } else {
    
  }
  map_key_expression_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key_expression,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.MapKeyExpression.map_key_expression)
}

// .io.substrait.ReferenceSegment child = 2;
inline bool ReferenceSegment_MapKeyExpression::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ReferenceSegment_MapKeyExpression::has_child() const {
  return _internal_has_child();
}
inline void ReferenceSegment_MapKeyExpression::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_MapKeyExpression::_internal_child() const {
  const ::io::substrait::ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::ReferenceSegment&>(
      ::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_MapKeyExpression::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.MapKeyExpression.child)
  return _internal_child();
}
inline void ReferenceSegment_MapKeyExpression::unsafe_arena_set_allocated_child(
    ::io::substrait::ReferenceSegment* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.MapKeyExpression.child)
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKeyExpression::release_child() {
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKeyExpression::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.MapKeyExpression.child)
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKeyExpression::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::ReferenceSegment>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_MapKeyExpression::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.MapKeyExpression.child)
  return _internal_mutable_child();
}
inline void ReferenceSegment_MapKeyExpression::set_allocated_child(::io::substrait::ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.MapKeyExpression.child)
}

// -------------------------------------------------------------------

// ReferenceSegment_StructField

// int32 field = 1;
inline void ReferenceSegment_StructField::clear_field() {
  field_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_StructField::_internal_field() const {
  return field_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_StructField::field() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.StructField.field)
  return _internal_field();
}
inline void ReferenceSegment_StructField::_internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_ = value;
}
inline void ReferenceSegment_StructField::set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.StructField.field)
}

// .io.substrait.ReferenceSegment child = 2;
inline bool ReferenceSegment_StructField::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ReferenceSegment_StructField::has_child() const {
  return _internal_has_child();
}
inline void ReferenceSegment_StructField::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_StructField::_internal_child() const {
  const ::io::substrait::ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::ReferenceSegment&>(
      ::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_StructField::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.StructField.child)
  return _internal_child();
}
inline void ReferenceSegment_StructField::unsafe_arena_set_allocated_child(
    ::io::substrait::ReferenceSegment* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.StructField.child)
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_StructField::release_child() {
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_StructField::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.StructField.child)
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_StructField::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::ReferenceSegment>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_StructField::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.StructField.child)
  return _internal_mutable_child();
}
inline void ReferenceSegment_StructField::set_allocated_child(::io::substrait::ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.StructField.child)
}

// -------------------------------------------------------------------

// ReferenceSegment_ListElement

// int32 offset = 1;
inline void ReferenceSegment_ListElement::clear_offset() {
  offset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListElement::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListElement::offset() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.ListElement.offset)
  return _internal_offset();
}
inline void ReferenceSegment_ListElement::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  offset_ = value;
}
inline void ReferenceSegment_ListElement::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.ListElement.offset)
}

// .io.substrait.ReferenceSegment child = 2;
inline bool ReferenceSegment_ListElement::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ReferenceSegment_ListElement::has_child() const {
  return _internal_has_child();
}
inline void ReferenceSegment_ListElement::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_ListElement::_internal_child() const {
  const ::io::substrait::ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::ReferenceSegment&>(
      ::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_ListElement::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.ListElement.child)
  return _internal_child();
}
inline void ReferenceSegment_ListElement::unsafe_arena_set_allocated_child(
    ::io::substrait::ReferenceSegment* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.ListElement.child)
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListElement::release_child() {
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListElement::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.ListElement.child)
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListElement::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::ReferenceSegment>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListElement::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.ListElement.child)
  return _internal_mutable_child();
}
inline void ReferenceSegment_ListElement::set_allocated_child(::io::substrait::ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.ListElement.child)
}

// -------------------------------------------------------------------

// ReferenceSegment_ListRange

// int32 start = 1;
inline void ReferenceSegment_ListRange::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListRange::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListRange::start() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.ListRange.start)
  return _internal_start();
}
inline void ReferenceSegment_ListRange::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void ReferenceSegment_ListRange::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.ListRange.start)
}

// int32 end = 2;
inline void ReferenceSegment_ListRange::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListRange::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReferenceSegment_ListRange::end() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.ListRange.end)
  return _internal_end();
}
inline void ReferenceSegment_ListRange::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void ReferenceSegment_ListRange::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:io.substrait.ReferenceSegment.ListRange.end)
}

// .io.substrait.ReferenceSegment child = 3;
inline bool ReferenceSegment_ListRange::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ReferenceSegment_ListRange::has_child() const {
  return _internal_has_child();
}
inline void ReferenceSegment_ListRange::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_ListRange::_internal_child() const {
  const ::io::substrait::ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::ReferenceSegment&>(
      ::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& ReferenceSegment_ListRange::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.ListRange.child)
  return _internal_child();
}
inline void ReferenceSegment_ListRange::unsafe_arena_set_allocated_child(
    ::io::substrait::ReferenceSegment* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.ListRange.child)
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListRange::release_child() {
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListRange::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.ListRange.child)
  
  ::io::substrait::ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListRange::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::ReferenceSegment>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::ReferenceSegment* ReferenceSegment_ListRange::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.ListRange.child)
  return _internal_mutable_child();
}
inline void ReferenceSegment_ListRange::set_allocated_child(::io::substrait::ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.ReferenceSegment.ListRange.child)
}

// -------------------------------------------------------------------

// ReferenceSegment

// .io.substrait.ReferenceSegment.MapKey map_key = 1;
inline bool ReferenceSegment::_internal_has_map_key() const {
  return reference_type_case() == kMapKey;
}
inline bool ReferenceSegment::has_map_key() const {
  return _internal_has_map_key();
}
inline void ReferenceSegment::set_has_map_key() {
  _oneof_case_[0] = kMapKey;
}
inline void ReferenceSegment::clear_map_key() {
  if (_internal_has_map_key()) {
    if (GetArena() == nullptr) {
      delete reference_type_.map_key_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment_MapKey* ReferenceSegment::release_map_key() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.map_key)
  if (_internal_has_map_key()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment_MapKey* temp = reference_type_.map_key_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment_MapKey& ReferenceSegment::_internal_map_key() const {
  return _internal_has_map_key()
      ? *reference_type_.map_key_
      : reinterpret_cast< ::io::substrait::ReferenceSegment_MapKey&>(::io::substrait::_ReferenceSegment_MapKey_default_instance_);
}
inline const ::io::substrait::ReferenceSegment_MapKey& ReferenceSegment::map_key() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.map_key)
  return _internal_map_key();
}
inline ::io::substrait::ReferenceSegment_MapKey* ReferenceSegment::unsafe_arena_release_map_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.ReferenceSegment.map_key)
  if (_internal_has_map_key()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment_MapKey* temp = reference_type_.map_key_;
    reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReferenceSegment::unsafe_arena_set_allocated_map_key(::io::substrait::ReferenceSegment_MapKey* map_key) {
  clear_reference_type();
  if (map_key) {
    set_has_map_key();
    reference_type_.map_key_ = map_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.map_key)
}
inline ::io::substrait::ReferenceSegment_MapKey* ReferenceSegment::_internal_mutable_map_key() {
  if (!_internal_has_map_key()) {
    clear_reference_type();
    set_has_map_key();
    reference_type_.map_key_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment_MapKey >(GetArena());
  }
  return reference_type_.map_key_;
}
inline ::io::substrait::ReferenceSegment_MapKey* ReferenceSegment::mutable_map_key() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.map_key)
  return _internal_mutable_map_key();
}

// .io.substrait.ReferenceSegment.MapKeyExpression expression = 2;
inline bool ReferenceSegment::_internal_has_expression() const {
  return reference_type_case() == kExpression;
}
inline bool ReferenceSegment::has_expression() const {
  return _internal_has_expression();
}
inline void ReferenceSegment::set_has_expression() {
  _oneof_case_[0] = kExpression;
}
inline void ReferenceSegment::clear_expression() {
  if (_internal_has_expression()) {
    if (GetArena() == nullptr) {
      delete reference_type_.expression_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment_MapKeyExpression* ReferenceSegment::release_expression() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.expression)
  if (_internal_has_expression()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment_MapKeyExpression* temp = reference_type_.expression_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment_MapKeyExpression& ReferenceSegment::_internal_expression() const {
  return _internal_has_expression()
      ? *reference_type_.expression_
      : reinterpret_cast< ::io::substrait::ReferenceSegment_MapKeyExpression&>(::io::substrait::_ReferenceSegment_MapKeyExpression_default_instance_);
}
inline const ::io::substrait::ReferenceSegment_MapKeyExpression& ReferenceSegment::expression() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.expression)
  return _internal_expression();
}
inline ::io::substrait::ReferenceSegment_MapKeyExpression* ReferenceSegment::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.ReferenceSegment.expression)
  if (_internal_has_expression()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment_MapKeyExpression* temp = reference_type_.expression_;
    reference_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReferenceSegment::unsafe_arena_set_allocated_expression(::io::substrait::ReferenceSegment_MapKeyExpression* expression) {
  clear_reference_type();
  if (expression) {
    set_has_expression();
    reference_type_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.expression)
}
inline ::io::substrait::ReferenceSegment_MapKeyExpression* ReferenceSegment::_internal_mutable_expression() {
  if (!_internal_has_expression()) {
    clear_reference_type();
    set_has_expression();
    reference_type_.expression_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment_MapKeyExpression >(GetArena());
  }
  return reference_type_.expression_;
}
inline ::io::substrait::ReferenceSegment_MapKeyExpression* ReferenceSegment::mutable_expression() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.expression)
  return _internal_mutable_expression();
}

// .io.substrait.ReferenceSegment.StructField struct_field = 3;
inline bool ReferenceSegment::_internal_has_struct_field() const {
  return reference_type_case() == kStructField;
}
inline bool ReferenceSegment::has_struct_field() const {
  return _internal_has_struct_field();
}
inline void ReferenceSegment::set_has_struct_field() {
  _oneof_case_[0] = kStructField;
}
inline void ReferenceSegment::clear_struct_field() {
  if (_internal_has_struct_field()) {
    if (GetArena() == nullptr) {
      delete reference_type_.struct_field_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment_StructField* ReferenceSegment::release_struct_field() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.struct_field)
  if (_internal_has_struct_field()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment_StructField* temp = reference_type_.struct_field_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment_StructField& ReferenceSegment::_internal_struct_field() const {
  return _internal_has_struct_field()
      ? *reference_type_.struct_field_
      : reinterpret_cast< ::io::substrait::ReferenceSegment_StructField&>(::io::substrait::_ReferenceSegment_StructField_default_instance_);
}
inline const ::io::substrait::ReferenceSegment_StructField& ReferenceSegment::struct_field() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.struct_field)
  return _internal_struct_field();
}
inline ::io::substrait::ReferenceSegment_StructField* ReferenceSegment::unsafe_arena_release_struct_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.ReferenceSegment.struct_field)
  if (_internal_has_struct_field()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment_StructField* temp = reference_type_.struct_field_;
    reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReferenceSegment::unsafe_arena_set_allocated_struct_field(::io::substrait::ReferenceSegment_StructField* struct_field) {
  clear_reference_type();
  if (struct_field) {
    set_has_struct_field();
    reference_type_.struct_field_ = struct_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.struct_field)
}
inline ::io::substrait::ReferenceSegment_StructField* ReferenceSegment::_internal_mutable_struct_field() {
  if (!_internal_has_struct_field()) {
    clear_reference_type();
    set_has_struct_field();
    reference_type_.struct_field_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment_StructField >(GetArena());
  }
  return reference_type_.struct_field_;
}
inline ::io::substrait::ReferenceSegment_StructField* ReferenceSegment::mutable_struct_field() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.struct_field)
  return _internal_mutable_struct_field();
}

// .io.substrait.ReferenceSegment.ListElement list_element = 4;
inline bool ReferenceSegment::_internal_has_list_element() const {
  return reference_type_case() == kListElement;
}
inline bool ReferenceSegment::has_list_element() const {
  return _internal_has_list_element();
}
inline void ReferenceSegment::set_has_list_element() {
  _oneof_case_[0] = kListElement;
}
inline void ReferenceSegment::clear_list_element() {
  if (_internal_has_list_element()) {
    if (GetArena() == nullptr) {
      delete reference_type_.list_element_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment_ListElement* ReferenceSegment::release_list_element() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.list_element)
  if (_internal_has_list_element()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment_ListElement* temp = reference_type_.list_element_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment_ListElement& ReferenceSegment::_internal_list_element() const {
  return _internal_has_list_element()
      ? *reference_type_.list_element_
      : reinterpret_cast< ::io::substrait::ReferenceSegment_ListElement&>(::io::substrait::_ReferenceSegment_ListElement_default_instance_);
}
inline const ::io::substrait::ReferenceSegment_ListElement& ReferenceSegment::list_element() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.list_element)
  return _internal_list_element();
}
inline ::io::substrait::ReferenceSegment_ListElement* ReferenceSegment::unsafe_arena_release_list_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.ReferenceSegment.list_element)
  if (_internal_has_list_element()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment_ListElement* temp = reference_type_.list_element_;
    reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReferenceSegment::unsafe_arena_set_allocated_list_element(::io::substrait::ReferenceSegment_ListElement* list_element) {
  clear_reference_type();
  if (list_element) {
    set_has_list_element();
    reference_type_.list_element_ = list_element;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.list_element)
}
inline ::io::substrait::ReferenceSegment_ListElement* ReferenceSegment::_internal_mutable_list_element() {
  if (!_internal_has_list_element()) {
    clear_reference_type();
    set_has_list_element();
    reference_type_.list_element_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment_ListElement >(GetArena());
  }
  return reference_type_.list_element_;
}
inline ::io::substrait::ReferenceSegment_ListElement* ReferenceSegment::mutable_list_element() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.list_element)
  return _internal_mutable_list_element();
}

// .io.substrait.ReferenceSegment.ListRange list_range = 5;
inline bool ReferenceSegment::_internal_has_list_range() const {
  return reference_type_case() == kListRange;
}
inline bool ReferenceSegment::has_list_range() const {
  return _internal_has_list_range();
}
inline void ReferenceSegment::set_has_list_range() {
  _oneof_case_[0] = kListRange;
}
inline void ReferenceSegment::clear_list_range() {
  if (_internal_has_list_range()) {
    if (GetArena() == nullptr) {
      delete reference_type_.list_range_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment_ListRange* ReferenceSegment::release_list_range() {
  // @@protoc_insertion_point(field_release:io.substrait.ReferenceSegment.list_range)
  if (_internal_has_list_range()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment_ListRange* temp = reference_type_.list_range_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.list_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment_ListRange& ReferenceSegment::_internal_list_range() const {
  return _internal_has_list_range()
      ? *reference_type_.list_range_
      : reinterpret_cast< ::io::substrait::ReferenceSegment_ListRange&>(::io::substrait::_ReferenceSegment_ListRange_default_instance_);
}
inline const ::io::substrait::ReferenceSegment_ListRange& ReferenceSegment::list_range() const {
  // @@protoc_insertion_point(field_get:io.substrait.ReferenceSegment.list_range)
  return _internal_list_range();
}
inline ::io::substrait::ReferenceSegment_ListRange* ReferenceSegment::unsafe_arena_release_list_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.ReferenceSegment.list_range)
  if (_internal_has_list_range()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment_ListRange* temp = reference_type_.list_range_;
    reference_type_.list_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReferenceSegment::unsafe_arena_set_allocated_list_range(::io::substrait::ReferenceSegment_ListRange* list_range) {
  clear_reference_type();
  if (list_range) {
    set_has_list_range();
    reference_type_.list_range_ = list_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.ReferenceSegment.list_range)
}
inline ::io::substrait::ReferenceSegment_ListRange* ReferenceSegment::_internal_mutable_list_range() {
  if (!_internal_has_list_range()) {
    clear_reference_type();
    set_has_list_range();
    reference_type_.list_range_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment_ListRange >(GetArena());
  }
  return reference_type_.list_range_;
}
inline ::io::substrait::ReferenceSegment_ListRange* ReferenceSegment::mutable_list_range() {
  // @@protoc_insertion_point(field_mutable:io.substrait.ReferenceSegment.list_range)
  return _internal_mutable_list_range();
}

inline bool ReferenceSegment::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void ReferenceSegment::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline ReferenceSegment::ReferenceTypeCase ReferenceSegment::reference_type_case() const {
  return ReferenceSegment::ReferenceTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MaskExpression_Select

// .io.substrait.MaskExpression.StructSelect struct = 1;
inline bool MaskExpression_Select::_internal_has_struct_() const {
  return type_case() == kStruct;
}
inline bool MaskExpression_Select::has_struct_() const {
  return _internal_has_struct_();
}
inline void MaskExpression_Select::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void MaskExpression_Select::clear_struct_() {
  if (_internal_has_struct_()) {
    if (GetArena() == nullptr) {
      delete type_.struct__;
    }
    clear_has_type();
  }
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression_Select::release_struct_() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.Select.struct)
  if (_internal_has_struct_()) {
    clear_has_type();
      ::io::substrait::MaskExpression_StructSelect* temp = type_.struct__;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_StructSelect& MaskExpression_Select::_internal_struct_() const {
  return _internal_has_struct_()
      ? *type_.struct__
      : reinterpret_cast< ::io::substrait::MaskExpression_StructSelect&>(::io::substrait::_MaskExpression_StructSelect_default_instance_);
}
inline const ::io::substrait::MaskExpression_StructSelect& MaskExpression_Select::struct_() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.Select.struct)
  return _internal_struct_();
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression_Select::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.Select.struct)
  if (_internal_has_struct_()) {
    clear_has_type();
    ::io::substrait::MaskExpression_StructSelect* temp = type_.struct__;
    type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_Select::unsafe_arena_set_allocated_struct_(::io::substrait::MaskExpression_StructSelect* struct_) {
  clear_type();
  if (struct_) {
    set_has_struct_();
    type_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.Select.struct)
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression_Select::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_type();
    set_has_struct_();
    type_.struct__ = CreateMaybeMessage< ::io::substrait::MaskExpression_StructSelect >(GetArena());
  }
  return type_.struct__;
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression_Select::mutable_struct_() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.Select.struct)
  return _internal_mutable_struct_();
}

// .io.substrait.MaskExpression.ListSelect list = 2;
inline bool MaskExpression_Select::_internal_has_list() const {
  return type_case() == kList;
}
inline bool MaskExpression_Select::has_list() const {
  return _internal_has_list();
}
inline void MaskExpression_Select::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void MaskExpression_Select::clear_list() {
  if (_internal_has_list()) {
    if (GetArena() == nullptr) {
      delete type_.list_;
    }
    clear_has_type();
  }
}
inline ::io::substrait::MaskExpression_ListSelect* MaskExpression_Select::release_list() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.Select.list)
  if (_internal_has_list()) {
    clear_has_type();
      ::io::substrait::MaskExpression_ListSelect* temp = type_.list_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_ListSelect& MaskExpression_Select::_internal_list() const {
  return _internal_has_list()
      ? *type_.list_
      : reinterpret_cast< ::io::substrait::MaskExpression_ListSelect&>(::io::substrait::_MaskExpression_ListSelect_default_instance_);
}
inline const ::io::substrait::MaskExpression_ListSelect& MaskExpression_Select::list() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.Select.list)
  return _internal_list();
}
inline ::io::substrait::MaskExpression_ListSelect* MaskExpression_Select::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.Select.list)
  if (_internal_has_list()) {
    clear_has_type();
    ::io::substrait::MaskExpression_ListSelect* temp = type_.list_;
    type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_Select::unsafe_arena_set_allocated_list(::io::substrait::MaskExpression_ListSelect* list) {
  clear_type();
  if (list) {
    set_has_list();
    type_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.Select.list)
}
inline ::io::substrait::MaskExpression_ListSelect* MaskExpression_Select::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_type();
    set_has_list();
    type_.list_ = CreateMaybeMessage< ::io::substrait::MaskExpression_ListSelect >(GetArena());
  }
  return type_.list_;
}
inline ::io::substrait::MaskExpression_ListSelect* MaskExpression_Select::mutable_list() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.Select.list)
  return _internal_mutable_list();
}

// .io.substrait.MaskExpression.MapSelect map = 3;
inline bool MaskExpression_Select::_internal_has_map() const {
  return type_case() == kMap;
}
inline bool MaskExpression_Select::has_map() const {
  return _internal_has_map();
}
inline void MaskExpression_Select::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void MaskExpression_Select::clear_map() {
  if (_internal_has_map()) {
    if (GetArena() == nullptr) {
      delete type_.map_;
    }
    clear_has_type();
  }
}
inline ::io::substrait::MaskExpression_MapSelect* MaskExpression_Select::release_map() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.Select.map)
  if (_internal_has_map()) {
    clear_has_type();
      ::io::substrait::MaskExpression_MapSelect* temp = type_.map_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_MapSelect& MaskExpression_Select::_internal_map() const {
  return _internal_has_map()
      ? *type_.map_
      : reinterpret_cast< ::io::substrait::MaskExpression_MapSelect&>(::io::substrait::_MaskExpression_MapSelect_default_instance_);
}
inline const ::io::substrait::MaskExpression_MapSelect& MaskExpression_Select::map() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.Select.map)
  return _internal_map();
}
inline ::io::substrait::MaskExpression_MapSelect* MaskExpression_Select::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.Select.map)
  if (_internal_has_map()) {
    clear_has_type();
    ::io::substrait::MaskExpression_MapSelect* temp = type_.map_;
    type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_Select::unsafe_arena_set_allocated_map(::io::substrait::MaskExpression_MapSelect* map) {
  clear_type();
  if (map) {
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.Select.map)
}
inline ::io::substrait::MaskExpression_MapSelect* MaskExpression_Select::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_type();
    set_has_map();
    type_.map_ = CreateMaybeMessage< ::io::substrait::MaskExpression_MapSelect >(GetArena());
  }
  return type_.map_;
}
inline ::io::substrait::MaskExpression_MapSelect* MaskExpression_Select::mutable_map() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.Select.map)
  return _internal_mutable_map();
}

inline bool MaskExpression_Select::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void MaskExpression_Select::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline MaskExpression_Select::TypeCase MaskExpression_Select::type_case() const {
  return MaskExpression_Select::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MaskExpression_StructSelect

// repeated .io.substrait.MaskExpression.StructItem struct_items = 1;
inline int MaskExpression_StructSelect::_internal_struct_items_size() const {
  return struct_items_.size();
}
inline int MaskExpression_StructSelect::struct_items_size() const {
  return _internal_struct_items_size();
}
inline void MaskExpression_StructSelect::clear_struct_items() {
  struct_items_.Clear();
}
inline ::io::substrait::MaskExpression_StructItem* MaskExpression_StructSelect::mutable_struct_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.StructSelect.struct_items)
  return struct_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_StructItem >*
MaskExpression_StructSelect::mutable_struct_items() {
  // @@protoc_insertion_point(field_mutable_list:io.substrait.MaskExpression.StructSelect.struct_items)
  return &struct_items_;
}
inline const ::io::substrait::MaskExpression_StructItem& MaskExpression_StructSelect::_internal_struct_items(int index) const {
  return struct_items_.Get(index);
}
inline const ::io::substrait::MaskExpression_StructItem& MaskExpression_StructSelect::struct_items(int index) const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.StructSelect.struct_items)
  return _internal_struct_items(index);
}
inline ::io::substrait::MaskExpression_StructItem* MaskExpression_StructSelect::_internal_add_struct_items() {
  return struct_items_.Add();
}
inline ::io::substrait::MaskExpression_StructItem* MaskExpression_StructSelect::add_struct_items() {
  // @@protoc_insertion_point(field_add:io.substrait.MaskExpression.StructSelect.struct_items)
  return _internal_add_struct_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_StructItem >&
MaskExpression_StructSelect::struct_items() const {
  // @@protoc_insertion_point(field_list:io.substrait.MaskExpression.StructSelect.struct_items)
  return struct_items_;
}

// -------------------------------------------------------------------

// MaskExpression_StructItem

// int32 field = 1;
inline void MaskExpression_StructItem::clear_field() {
  field_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_StructItem::_internal_field() const {
  return field_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_StructItem::field() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.StructItem.field)
  return _internal_field();
}
inline void MaskExpression_StructItem::_internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_ = value;
}
inline void MaskExpression_StructItem::set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.StructItem.field)
}

// .io.substrait.MaskExpression.Select child = 2;
inline bool MaskExpression_StructItem::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool MaskExpression_StructItem::has_child() const {
  return _internal_has_child();
}
inline void MaskExpression_StructItem::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_StructItem::_internal_child() const {
  const ::io::substrait::MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::MaskExpression_Select&>(
      ::io::substrait::_MaskExpression_Select_default_instance_);
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_StructItem::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.StructItem.child)
  return _internal_child();
}
inline void MaskExpression_StructItem::unsafe_arena_set_allocated_child(
    ::io::substrait::MaskExpression_Select* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.StructItem.child)
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_StructItem::release_child() {
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_StructItem::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.StructItem.child)
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_StructItem::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::MaskExpression_Select>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_StructItem::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.StructItem.child)
  return _internal_mutable_child();
}
inline void MaskExpression_StructItem::set_allocated_child(::io::substrait::MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.StructItem.child)
}

// -------------------------------------------------------------------

// MaskExpression_ListSelect_ListSelectItem_ListElement

// int32 field = 1;
inline void MaskExpression_ListSelect_ListSelectItem_ListElement::clear_field() {
  field_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_field() const {
  return field_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListElement::field() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
  return _internal_field();
}
inline void MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_ = value;
}
inline void MaskExpression_ListSelect_ListSelectItem_ListElement::set_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
}

// -------------------------------------------------------------------

// MaskExpression_ListSelect_ListSelectItem_ListSlice

// int32 start = 1;
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListSlice::start() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
  return _internal_start();
}
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
}

// int32 end = 2;
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MaskExpression_ListSelect_ListSelectItem_ListSlice::end() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
  return _internal_end();
}
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void MaskExpression_ListSelect_ListSelectItem_ListSlice::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
}

// -------------------------------------------------------------------

// MaskExpression_ListSelect_ListSelectItem

// .io.substrait.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
inline bool MaskExpression_ListSelect_ListSelectItem::_internal_has_item() const {
  return type_case() == kItem;
}
inline bool MaskExpression_ListSelect_ListSelectItem::has_item() const {
  return _internal_has_item();
}
inline void MaskExpression_ListSelect_ListSelectItem::set_has_item() {
  _oneof_case_[0] = kItem;
}
inline void MaskExpression_ListSelect_ListSelectItem::clear_item() {
  if (_internal_has_item()) {
    if (GetArena() == nullptr) {
      delete type_.item_;
    }
    clear_has_type();
  }
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* MaskExpression_ListSelect_ListSelectItem::release_item() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.ListSelect.ListSelectItem.item)
  if (_internal_has_item()) {
    clear_has_type();
      ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* temp = type_.item_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement& MaskExpression_ListSelect_ListSelectItem::_internal_item() const {
  return _internal_has_item()
      ? *type_.item_
      : reinterpret_cast< ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement&>(::io::substrait::_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement& MaskExpression_ListSelect_ListSelectItem::item() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.ListSelectItem.item)
  return _internal_item();
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.ListSelect.ListSelectItem.item)
  if (_internal_has_item()) {
    clear_has_type();
    ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* temp = type_.item_;
    type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_item(::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* item) {
  clear_type();
  if (item) {
    set_has_item();
    type_.item_ = item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.ListSelect.ListSelectItem.item)
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* MaskExpression_ListSelect_ListSelectItem::_internal_mutable_item() {
  if (!_internal_has_item()) {
    clear_type();
    set_has_item();
    type_.item_ = CreateMaybeMessage< ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement >(GetArena());
  }
  return type_.item_;
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListElement* MaskExpression_ListSelect_ListSelectItem::mutable_item() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.ListSelect.ListSelectItem.item)
  return _internal_mutable_item();
}

// .io.substrait.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
inline bool MaskExpression_ListSelect_ListSelectItem::_internal_has_slice() const {
  return type_case() == kSlice;
}
inline bool MaskExpression_ListSelect_ListSelectItem::has_slice() const {
  return _internal_has_slice();
}
inline void MaskExpression_ListSelect_ListSelectItem::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void MaskExpression_ListSelect_ListSelectItem::clear_slice() {
  if (_internal_has_slice()) {
    if (GetArena() == nullptr) {
      delete type_.slice_;
    }
    clear_has_type();
  }
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* MaskExpression_ListSelect_ListSelectItem::release_slice() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.ListSelect.ListSelectItem.slice)
  if (_internal_has_slice()) {
    clear_has_type();
      ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* temp = type_.slice_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice& MaskExpression_ListSelect_ListSelectItem::_internal_slice() const {
  return _internal_has_slice()
      ? *type_.slice_
      : reinterpret_cast< ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice&>(::io::substrait::_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice& MaskExpression_ListSelect_ListSelectItem::slice() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.ListSelectItem.slice)
  return _internal_slice();
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.ListSelect.ListSelectItem.slice)
  if (_internal_has_slice()) {
    clear_has_type();
    ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* temp = type_.slice_;
    type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_slice(::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* slice) {
  clear_type();
  if (slice) {
    set_has_slice();
    type_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.ListSelect.ListSelectItem.slice)
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* MaskExpression_ListSelect_ListSelectItem::_internal_mutable_slice() {
  if (!_internal_has_slice()) {
    clear_type();
    set_has_slice();
    type_.slice_ = CreateMaybeMessage< ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice >(GetArena());
  }
  return type_.slice_;
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem_ListSlice* MaskExpression_ListSelect_ListSelectItem::mutable_slice() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.ListSelect.ListSelectItem.slice)
  return _internal_mutable_slice();
}

inline bool MaskExpression_ListSelect_ListSelectItem::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void MaskExpression_ListSelect_ListSelectItem::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline MaskExpression_ListSelect_ListSelectItem::TypeCase MaskExpression_ListSelect_ListSelectItem::type_case() const {
  return MaskExpression_ListSelect_ListSelectItem::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MaskExpression_ListSelect

// repeated .io.substrait.MaskExpression.ListSelect.ListSelectItem selection = 1;
inline int MaskExpression_ListSelect::_internal_selection_size() const {
  return selection_.size();
}
inline int MaskExpression_ListSelect::selection_size() const {
  return _internal_selection_size();
}
inline void MaskExpression_ListSelect::clear_selection() {
  selection_.Clear();
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem* MaskExpression_ListSelect::mutable_selection(int index) {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.ListSelect.selection)
  return selection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_ListSelect_ListSelectItem >*
MaskExpression_ListSelect::mutable_selection() {
  // @@protoc_insertion_point(field_mutable_list:io.substrait.MaskExpression.ListSelect.selection)
  return &selection_;
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem& MaskExpression_ListSelect::_internal_selection(int index) const {
  return selection_.Get(index);
}
inline const ::io::substrait::MaskExpression_ListSelect_ListSelectItem& MaskExpression_ListSelect::selection(int index) const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.selection)
  return _internal_selection(index);
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem* MaskExpression_ListSelect::_internal_add_selection() {
  return selection_.Add();
}
inline ::io::substrait::MaskExpression_ListSelect_ListSelectItem* MaskExpression_ListSelect::add_selection() {
  // @@protoc_insertion_point(field_add:io.substrait.MaskExpression.ListSelect.selection)
  return _internal_add_selection();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::substrait::MaskExpression_ListSelect_ListSelectItem >&
MaskExpression_ListSelect::selection() const {
  // @@protoc_insertion_point(field_list:io.substrait.MaskExpression.ListSelect.selection)
  return selection_;
}

// .io.substrait.MaskExpression.Select child = 2;
inline bool MaskExpression_ListSelect::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool MaskExpression_ListSelect::has_child() const {
  return _internal_has_child();
}
inline void MaskExpression_ListSelect::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_ListSelect::_internal_child() const {
  const ::io::substrait::MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::MaskExpression_Select&>(
      ::io::substrait::_MaskExpression_Select_default_instance_);
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_ListSelect::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.ListSelect.child)
  return _internal_child();
}
inline void MaskExpression_ListSelect::unsafe_arena_set_allocated_child(
    ::io::substrait::MaskExpression_Select* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.ListSelect.child)
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_ListSelect::release_child() {
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_ListSelect::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.ListSelect.child)
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_ListSelect::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::MaskExpression_Select>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_ListSelect::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.ListSelect.child)
  return _internal_mutable_child();
}
inline void MaskExpression_ListSelect::set_allocated_child(::io::substrait::MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.ListSelect.child)
}

// -------------------------------------------------------------------

// MaskExpression_MapSelect_MapKey

// string map_key = 1;
inline void MaskExpression_MapSelect_MapKey::clear_map_key() {
  map_key_.ClearToEmpty();
}
inline const std::string& MaskExpression_MapSelect_MapKey::map_key() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.MapSelect.MapKey.map_key)
  return _internal_map_key();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MaskExpression_MapSelect_MapKey::set_map_key(ArgT0&& arg0, ArgT... args) {
 
 map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.MapSelect.MapKey.map_key)
}
inline std::string* MaskExpression_MapSelect_MapKey::mutable_map_key() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.MapSelect.MapKey.map_key)
  return _internal_mutable_map_key();
}
inline const std::string& MaskExpression_MapSelect_MapKey::_internal_map_key() const {
  return map_key_.Get();
}
inline void MaskExpression_MapSelect_MapKey::_internal_set_map_key(const std::string& value) {
  
  map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MaskExpression_MapSelect_MapKey::_internal_mutable_map_key() {
  
  return map_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MaskExpression_MapSelect_MapKey::release_map_key() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.MapSelect.MapKey.map_key)
  return map_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MaskExpression_MapSelect_MapKey::set_allocated_map_key(std::string* map_key) {
  if (map_key != nullptr) {
    
  } else {
    
  }
  map_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.MapSelect.MapKey.map_key)
}

// -------------------------------------------------------------------

// MaskExpression_MapSelect_MapKeyExpression

// string map_key_expression = 1;
inline void MaskExpression_MapSelect_MapKeyExpression::clear_map_key_expression() {
  map_key_expression_.ClearToEmpty();
}
inline const std::string& MaskExpression_MapSelect_MapKeyExpression::map_key_expression() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _internal_map_key_expression();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(ArgT0&& arg0, ArgT... args) {
 
 map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
inline std::string* MaskExpression_MapSelect_MapKeyExpression::mutable_map_key_expression() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _internal_mutable_map_key_expression();
}
inline const std::string& MaskExpression_MapSelect_MapKeyExpression::_internal_map_key_expression() const {
  return map_key_expression_.Get();
}
inline void MaskExpression_MapSelect_MapKeyExpression::_internal_set_map_key_expression(const std::string& value) {
  
  map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* MaskExpression_MapSelect_MapKeyExpression::_internal_mutable_map_key_expression() {
  
  return map_key_expression_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MaskExpression_MapSelect_MapKeyExpression::release_map_key_expression() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return map_key_expression_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MaskExpression_MapSelect_MapKeyExpression::set_allocated_map_key_expression(std::string* map_key_expression) {
  if (map_key_expression != nullptr) {
    
  } else {
    
  }
  map_key_expression_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key_expression,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}

// -------------------------------------------------------------------

// MaskExpression_MapSelect

// .io.substrait.MaskExpression.MapSelect.MapKey key = 1;
inline bool MaskExpression_MapSelect::_internal_has_key() const {
  return select_case() == kKey;
}
inline bool MaskExpression_MapSelect::has_key() const {
  return _internal_has_key();
}
inline void MaskExpression_MapSelect::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void MaskExpression_MapSelect::clear_key() {
  if (_internal_has_key()) {
    if (GetArena() == nullptr) {
      delete select_.key_;
    }
    clear_has_select();
  }
}
inline ::io::substrait::MaskExpression_MapSelect_MapKey* MaskExpression_MapSelect::release_key() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.MapSelect.key)
  if (_internal_has_key()) {
    clear_has_select();
      ::io::substrait::MaskExpression_MapSelect_MapKey* temp = select_.key_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_MapSelect_MapKey& MaskExpression_MapSelect::_internal_key() const {
  return _internal_has_key()
      ? *select_.key_
      : reinterpret_cast< ::io::substrait::MaskExpression_MapSelect_MapKey&>(::io::substrait::_MaskExpression_MapSelect_MapKey_default_instance_);
}
inline const ::io::substrait::MaskExpression_MapSelect_MapKey& MaskExpression_MapSelect::key() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.MapSelect.key)
  return _internal_key();
}
inline ::io::substrait::MaskExpression_MapSelect_MapKey* MaskExpression_MapSelect::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.MapSelect.key)
  if (_internal_has_key()) {
    clear_has_select();
    ::io::substrait::MaskExpression_MapSelect_MapKey* temp = select_.key_;
    select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_MapSelect::unsafe_arena_set_allocated_key(::io::substrait::MaskExpression_MapSelect_MapKey* key) {
  clear_select();
  if (key) {
    set_has_key();
    select_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.MapSelect.key)
}
inline ::io::substrait::MaskExpression_MapSelect_MapKey* MaskExpression_MapSelect::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_select();
    set_has_key();
    select_.key_ = CreateMaybeMessage< ::io::substrait::MaskExpression_MapSelect_MapKey >(GetArena());
  }
  return select_.key_;
}
inline ::io::substrait::MaskExpression_MapSelect_MapKey* MaskExpression_MapSelect::mutable_key() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.MapSelect.key)
  return _internal_mutable_key();
}

// .io.substrait.MaskExpression.MapSelect.MapKeyExpression expression = 2;
inline bool MaskExpression_MapSelect::_internal_has_expression() const {
  return select_case() == kExpression;
}
inline bool MaskExpression_MapSelect::has_expression() const {
  return _internal_has_expression();
}
inline void MaskExpression_MapSelect::set_has_expression() {
  _oneof_case_[0] = kExpression;
}
inline void MaskExpression_MapSelect::clear_expression() {
  if (_internal_has_expression()) {
    if (GetArena() == nullptr) {
      delete select_.expression_;
    }
    clear_has_select();
  }
}
inline ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* MaskExpression_MapSelect::release_expression() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.MapSelect.expression)
  if (_internal_has_expression()) {
    clear_has_select();
      ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* temp = select_.expression_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression_MapSelect_MapKeyExpression& MaskExpression_MapSelect::_internal_expression() const {
  return _internal_has_expression()
      ? *select_.expression_
      : reinterpret_cast< ::io::substrait::MaskExpression_MapSelect_MapKeyExpression&>(::io::substrait::_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
}
inline const ::io::substrait::MaskExpression_MapSelect_MapKeyExpression& MaskExpression_MapSelect::expression() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.MapSelect.expression)
  return _internal_expression();
}
inline ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* MaskExpression_MapSelect::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.MaskExpression.MapSelect.expression)
  if (_internal_has_expression()) {
    clear_has_select();
    ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* temp = select_.expression_;
    select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MaskExpression_MapSelect::unsafe_arena_set_allocated_expression(::io::substrait::MaskExpression_MapSelect_MapKeyExpression* expression) {
  clear_select();
  if (expression) {
    set_has_expression();
    select_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.MapSelect.expression)
}
inline ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* MaskExpression_MapSelect::_internal_mutable_expression() {
  if (!_internal_has_expression()) {
    clear_select();
    set_has_expression();
    select_.expression_ = CreateMaybeMessage< ::io::substrait::MaskExpression_MapSelect_MapKeyExpression >(GetArena());
  }
  return select_.expression_;
}
inline ::io::substrait::MaskExpression_MapSelect_MapKeyExpression* MaskExpression_MapSelect::mutable_expression() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.MapSelect.expression)
  return _internal_mutable_expression();
}

// .io.substrait.MaskExpression.Select child = 3;
inline bool MaskExpression_MapSelect::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool MaskExpression_MapSelect::has_child() const {
  return _internal_has_child();
}
inline void MaskExpression_MapSelect::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_MapSelect::_internal_child() const {
  const ::io::substrait::MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::MaskExpression_Select&>(
      ::io::substrait::_MaskExpression_Select_default_instance_);
}
inline const ::io::substrait::MaskExpression_Select& MaskExpression_MapSelect::child() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.MapSelect.child)
  return _internal_child();
}
inline void MaskExpression_MapSelect::unsafe_arena_set_allocated_child(
    ::io::substrait::MaskExpression_Select* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.MapSelect.child)
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_MapSelect::release_child() {
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_MapSelect::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.MapSelect.child)
  
  ::io::substrait::MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_MapSelect::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::MaskExpression_Select>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::io::substrait::MaskExpression_Select* MaskExpression_MapSelect::mutable_child() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.MapSelect.child)
  return _internal_mutable_child();
}
inline void MaskExpression_MapSelect::set_allocated_child(::io::substrait::MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.MapSelect.child)
}

inline bool MaskExpression_MapSelect::has_select() const {
  return select_case() != SELECT_NOT_SET;
}
inline void MaskExpression_MapSelect::clear_has_select() {
  _oneof_case_[0] = SELECT_NOT_SET;
}
inline MaskExpression_MapSelect::SelectCase MaskExpression_MapSelect::select_case() const {
  return MaskExpression_MapSelect::SelectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MaskExpression

// .io.substrait.MaskExpression.StructSelect select = 1;
inline bool MaskExpression::_internal_has_select() const {
  return this != internal_default_instance() && select_ != nullptr;
}
inline bool MaskExpression::has_select() const {
  return _internal_has_select();
}
inline void MaskExpression::clear_select() {
  if (GetArena() == nullptr && select_ != nullptr) {
    delete select_;
  }
  select_ = nullptr;
}
inline const ::io::substrait::MaskExpression_StructSelect& MaskExpression::_internal_select() const {
  const ::io::substrait::MaskExpression_StructSelect* p = select_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::substrait::MaskExpression_StructSelect&>(
      ::io::substrait::_MaskExpression_StructSelect_default_instance_);
}
inline const ::io::substrait::MaskExpression_StructSelect& MaskExpression::select() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.select)
  return _internal_select();
}
inline void MaskExpression::unsafe_arena_set_allocated_select(
    ::io::substrait::MaskExpression_StructSelect* select) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_);
  }
  select_ = select;
  if (select) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.MaskExpression.select)
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression::release_select() {
  
  ::io::substrait::MaskExpression_StructSelect* temp = select_;
  select_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_release:io.substrait.MaskExpression.select)
  
  ::io::substrait::MaskExpression_StructSelect* temp = select_;
  select_ = nullptr;
  return temp;
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression::_internal_mutable_select() {
  
  if (select_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::substrait::MaskExpression_StructSelect>(GetArena());
    select_ = p;
  }
  return select_;
}
inline ::io::substrait::MaskExpression_StructSelect* MaskExpression::mutable_select() {
  // @@protoc_insertion_point(field_mutable:io.substrait.MaskExpression.select)
  return _internal_mutable_select();
}
inline void MaskExpression::set_allocated_select(::io::substrait::MaskExpression_StructSelect* select) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete select_;
  }
  if (select) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(select);
    if (message_arena != submessage_arena) {
      select = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select, submessage_arena);
    }
    
  } else {
    
  }
  select_ = select;
  // @@protoc_insertion_point(field_set_allocated:io.substrait.MaskExpression.select)
}

// bool maintain_singular_struct = 2;
inline void MaskExpression::clear_maintain_singular_struct() {
  maintain_singular_struct_ = false;
}
inline bool MaskExpression::_internal_maintain_singular_struct() const {
  return maintain_singular_struct_;
}
inline bool MaskExpression::maintain_singular_struct() const {
  // @@protoc_insertion_point(field_get:io.substrait.MaskExpression.maintain_singular_struct)
  return _internal_maintain_singular_struct();
}
inline void MaskExpression::_internal_set_maintain_singular_struct(bool value) {
  
  maintain_singular_struct_ = value;
}
inline void MaskExpression::set_maintain_singular_struct(bool value) {
  _internal_set_maintain_singular_struct(value);
  // @@protoc_insertion_point(field_set:io.substrait.MaskExpression.maintain_singular_struct)
}

// -------------------------------------------------------------------

// FieldReference

// .io.substrait.ReferenceSegment direct_reference = 1;
inline bool FieldReference::_internal_has_direct_reference() const {
  return reference_type_case() == kDirectReference;
}
inline bool FieldReference::has_direct_reference() const {
  return _internal_has_direct_reference();
}
inline void FieldReference::set_has_direct_reference() {
  _oneof_case_[0] = kDirectReference;
}
inline void FieldReference::clear_direct_reference() {
  if (_internal_has_direct_reference()) {
    if (GetArena() == nullptr) {
      delete reference_type_.direct_reference_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::ReferenceSegment* FieldReference::release_direct_reference() {
  // @@protoc_insertion_point(field_release:io.substrait.FieldReference.direct_reference)
  if (_internal_has_direct_reference()) {
    clear_has_reference_type();
      ::io::substrait::ReferenceSegment* temp = reference_type_.direct_reference_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::ReferenceSegment& FieldReference::_internal_direct_reference() const {
  return _internal_has_direct_reference()
      ? *reference_type_.direct_reference_
      : reinterpret_cast< ::io::substrait::ReferenceSegment&>(::io::substrait::_ReferenceSegment_default_instance_);
}
inline const ::io::substrait::ReferenceSegment& FieldReference::direct_reference() const {
  // @@protoc_insertion_point(field_get:io.substrait.FieldReference.direct_reference)
  return _internal_direct_reference();
}
inline ::io::substrait::ReferenceSegment* FieldReference::unsafe_arena_release_direct_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.FieldReference.direct_reference)
  if (_internal_has_direct_reference()) {
    clear_has_reference_type();
    ::io::substrait::ReferenceSegment* temp = reference_type_.direct_reference_;
    reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldReference::unsafe_arena_set_allocated_direct_reference(::io::substrait::ReferenceSegment* direct_reference) {
  clear_reference_type();
  if (direct_reference) {
    set_has_direct_reference();
    reference_type_.direct_reference_ = direct_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.FieldReference.direct_reference)
}
inline ::io::substrait::ReferenceSegment* FieldReference::_internal_mutable_direct_reference() {
  if (!_internal_has_direct_reference()) {
    clear_reference_type();
    set_has_direct_reference();
    reference_type_.direct_reference_ = CreateMaybeMessage< ::io::substrait::ReferenceSegment >(GetArena());
  }
  return reference_type_.direct_reference_;
}
inline ::io::substrait::ReferenceSegment* FieldReference::mutable_direct_reference() {
  // @@protoc_insertion_point(field_mutable:io.substrait.FieldReference.direct_reference)
  return _internal_mutable_direct_reference();
}

// .io.substrait.MaskExpression masked_reference = 2;
inline bool FieldReference::_internal_has_masked_reference() const {
  return reference_type_case() == kMaskedReference;
}
inline bool FieldReference::has_masked_reference() const {
  return _internal_has_masked_reference();
}
inline void FieldReference::set_has_masked_reference() {
  _oneof_case_[0] = kMaskedReference;
}
inline void FieldReference::clear_masked_reference() {
  if (_internal_has_masked_reference()) {
    if (GetArena() == nullptr) {
      delete reference_type_.masked_reference_;
    }
    clear_has_reference_type();
  }
}
inline ::io::substrait::MaskExpression* FieldReference::release_masked_reference() {
  // @@protoc_insertion_point(field_release:io.substrait.FieldReference.masked_reference)
  if (_internal_has_masked_reference()) {
    clear_has_reference_type();
      ::io::substrait::MaskExpression* temp = reference_type_.masked_reference_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::substrait::MaskExpression& FieldReference::_internal_masked_reference() const {
  return _internal_has_masked_reference()
      ? *reference_type_.masked_reference_
      : reinterpret_cast< ::io::substrait::MaskExpression&>(::io::substrait::_MaskExpression_default_instance_);
}
inline const ::io::substrait::MaskExpression& FieldReference::masked_reference() const {
  // @@protoc_insertion_point(field_get:io.substrait.FieldReference.masked_reference)
  return _internal_masked_reference();
}
inline ::io::substrait::MaskExpression* FieldReference::unsafe_arena_release_masked_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.substrait.FieldReference.masked_reference)
  if (_internal_has_masked_reference()) {
    clear_has_reference_type();
    ::io::substrait::MaskExpression* temp = reference_type_.masked_reference_;
    reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldReference::unsafe_arena_set_allocated_masked_reference(::io::substrait::MaskExpression* masked_reference) {
  clear_reference_type();
  if (masked_reference) {
    set_has_masked_reference();
    reference_type_.masked_reference_ = masked_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.substrait.FieldReference.masked_reference)
}
inline ::io::substrait::MaskExpression* FieldReference::_internal_mutable_masked_reference() {
  if (!_internal_has_masked_reference()) {
    clear_reference_type();
    set_has_masked_reference();
    reference_type_.masked_reference_ = CreateMaybeMessage< ::io::substrait::MaskExpression >(GetArena());
  }
  return reference_type_.masked_reference_;
}
inline ::io::substrait::MaskExpression* FieldReference::mutable_masked_reference() {
  // @@protoc_insertion_point(field_mutable:io.substrait.FieldReference.masked_reference)
  return _internal_mutable_masked_reference();
}

inline bool FieldReference::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void FieldReference::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline FieldReference::ReferenceTypeCase FieldReference::reference_type_case() const {
  return FieldReference::ReferenceTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace substrait
}  // namespace io

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_selection_2eproto
